/*
My Data My Consent - Developer API

Unleashing the power of consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: 1.0
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/sdk

import (
	"encoding/json"
	"time"
	"fmt"
)

// FinancialAccount struct for FinancialAccount
type FinancialAccount struct {
	FinancialAccountEquity *FinancialAccountEquity
	FinancialAccountMutualFund *FinancialAccountMutualFund
	FinancialAccountSip *FinancialAccountSip
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *FinancialAccount) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	// check if the discriminator value is 'Equity'
	if jsonDict["type"] == "Equity" {
		// try to unmarshal JSON data into FinancialAccountEquity
		err = json.Unmarshal(data, &dst.FinancialAccountEquity);
		if err == nil {
			jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
			if string(jsonFinancialAccountEquity) == "{}" { // empty struct
				dst.FinancialAccountEquity = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquity, return on the first match
			}
		} else {
			dst.FinancialAccountEquity = nil
		}
	}

	// check if the discriminator value is 'FinancialAccount_Equity'
	if jsonDict["type"] == "FinancialAccount_Equity" {
		// try to unmarshal JSON data into FinancialAccountEquity
		err = json.Unmarshal(data, &dst.FinancialAccountEquity);
		if err == nil {
			jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
			if string(jsonFinancialAccountEquity) == "{}" { // empty struct
				dst.FinancialAccountEquity = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquity, return on the first match
			}
		} else {
			dst.FinancialAccountEquity = nil
		}
	}

	// check if the discriminator value is 'FinancialAccount_MutualFund'
	if jsonDict["type"] == "FinancialAccount_MutualFund" {
		// try to unmarshal JSON data into FinancialAccountMutualFund
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
		if err == nil {
			jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
			if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
				dst.FinancialAccountMutualFund = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFund = nil
		}
	}

	// check if the discriminator value is 'FinancialAccount_Sip'
	if jsonDict["type"] == "FinancialAccount_Sip" {
		// try to unmarshal JSON data into FinancialAccountSip
		err = json.Unmarshal(data, &dst.FinancialAccountSip);
		if err == nil {
			jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
			if string(jsonFinancialAccountSip) == "{}" { // empty struct
				dst.FinancialAccountSip = nil
			} else {
				return nil // data stored in dst.FinancialAccountSip, return on the first match
			}
		} else {
			dst.FinancialAccountSip = nil
		}
	}

	// check if the discriminator value is 'MutualFund'
	if jsonDict["type"] == "MutualFund" {
		// try to unmarshal JSON data into FinancialAccountMutualFund
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
		if err == nil {
			jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
			if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
				dst.FinancialAccountMutualFund = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFund = nil
		}
	}

	// check if the discriminator value is 'Sip'
	if jsonDict["type"] == "Sip" {
		// try to unmarshal JSON data into FinancialAccountSip
		err = json.Unmarshal(data, &dst.FinancialAccountSip);
		if err == nil {
			jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
			if string(jsonFinancialAccountSip) == "{}" { // empty struct
				dst.FinancialAccountSip = nil
			} else {
				return nil // data stored in dst.FinancialAccountSip, return on the first match
			}
		} else {
			dst.FinancialAccountSip = nil
		}
	}

	// try to unmarshal JSON data into FinancialAccountEquity
	err = json.Unmarshal(data, &dst.FinancialAccountEquity);
	if err == nil {
		jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
		if string(jsonFinancialAccountEquity) == "{}" { // empty struct
			dst.FinancialAccountEquity = nil
		} else {
			return nil // data stored in dst.FinancialAccountEquity, return on the first match
		}
	} else {
		dst.FinancialAccountEquity = nil
	}

	// try to unmarshal JSON data into FinancialAccountMutualFund
	err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
	if err == nil {
		jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
		if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
			dst.FinancialAccountMutualFund = nil
		} else {
			return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
		}
	} else {
		dst.FinancialAccountMutualFund = nil
	}

	// try to unmarshal JSON data into FinancialAccountSip
	err = json.Unmarshal(data, &dst.FinancialAccountSip);
	if err == nil {
		jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
		if string(jsonFinancialAccountSip) == "{}" { // empty struct
			dst.FinancialAccountSip = nil
		} else {
			return nil // data stored in dst.FinancialAccountSip, return on the first match
		}
	} else {
		dst.FinancialAccountSip = nil
	}

	return fmt.Errorf("Data failed to match schemas in anyOf(FinancialAccount)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *FinancialAccount) MarshalJSON() ([]byte, error) {
	if src.FinancialAccountEquity != nil {
		return json.Marshal(&src.FinancialAccountEquity)
	}

	if src.FinancialAccountMutualFund != nil {
		return json.Marshal(&src.FinancialAccountMutualFund)
	}

	if src.FinancialAccountSip != nil {
		return json.Marshal(&src.FinancialAccountSip)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableFinancialAccount struct {
	value *FinancialAccount
	isSet bool
}

func (v NullableFinancialAccount) Get() *FinancialAccount {
	return v.value
}

func (v *NullableFinancialAccount) Set(val *FinancialAccount) {
	v.value = val
	v.isSet = true
}

func (v NullableFinancialAccount) IsSet() bool {
	return v.isSet
}

func (v *NullableFinancialAccount) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFinancialAccount(val *FinancialAccount) *NullableFinancialAccount {
	return &NullableFinancialAccount{value: val, isSet: true}
}

func (v NullableFinancialAccount) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFinancialAccount) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


