/*
My Data My Consent - Developer API

Unleashing the power of consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: 1.0
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/sdk

import (
	"encoding/json"
	"fmt"
)

// FinancialAccount struct for FinancialAccount
type FinancialAccount struct {
	FinancialAccountAif *FinancialAccountAif
	FinancialAccountBillPayment *FinancialAccountBillPayment
	FinancialAccountBond *FinancialAccountBond
	FinancialAccountCIS *FinancialAccountCIS
	FinancialAccountCertificateOfDeposit *FinancialAccountCertificateOfDeposit
	FinancialAccountCommercialPaper *FinancialAccountCommercialPaper
	FinancialAccountCreditCard *FinancialAccountCreditCard
	FinancialAccountDebenture *FinancialAccountDebenture
	FinancialAccountDeposit *FinancialAccountDeposit
	FinancialAccountEpf *FinancialAccountEpf
	FinancialAccountEquity *FinancialAccountEquity
	FinancialAccountEtf *FinancialAccountEtf
	FinancialAccountGovtSecurity *FinancialAccountGovtSecurity
	FinancialAccountIdr *FinancialAccountIdr
	FinancialAccountInsurancePolicy *FinancialAccountInsurancePolicy
	FinancialAccountInvit *FinancialAccountInvit
	FinancialAccountLoan *FinancialAccountLoan
	FinancialAccountMutualFund *FinancialAccountMutualFund
	FinancialAccountNps *FinancialAccountNps
	FinancialAccountPpf *FinancialAccountPpf
	FinancialAccountRecurringDeposit *FinancialAccountRecurringDeposit
	FinancialAccountReit *FinancialAccountReit
	FinancialAccountSip *FinancialAccountSip
	FinancialAccountTermDeposit *FinancialAccountTermDeposit
	FinancialAccountUlip *FinancialAccountUlip
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *FinancialAccount) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	// check if the discriminator value is 'Aif'
	if jsonDict["type"] == "Aif" {
		// try to unmarshal JSON data into FinancialAccountAif
		err = json.Unmarshal(data, &dst.FinancialAccountAif);
		if err == nil {
			jsonFinancialAccountAif, _ := json.Marshal(dst.FinancialAccountAif)
			if string(jsonFinancialAccountAif) == "{}" { // empty struct
				dst.FinancialAccountAif = nil
			} else {
				return nil // data stored in dst.FinancialAccountAif, return on the first match
			}
		} else {
			dst.FinancialAccountAif = nil
		}
	}

	// check if the discriminator value is 'BillPayment'
	if jsonDict["type"] == "BillPayment" {
		// try to unmarshal JSON data into FinancialAccountBillPayment
		err = json.Unmarshal(data, &dst.FinancialAccountBillPayment);
		if err == nil {
			jsonFinancialAccountBillPayment, _ := json.Marshal(dst.FinancialAccountBillPayment)
			if string(jsonFinancialAccountBillPayment) == "{}" { // empty struct
				dst.FinancialAccountBillPayment = nil
			} else {
				return nil // data stored in dst.FinancialAccountBillPayment, return on the first match
			}
		} else {
			dst.FinancialAccountBillPayment = nil
		}
	}

	// check if the discriminator value is 'Bond'
	if jsonDict["type"] == "Bond" {
		// try to unmarshal JSON data into FinancialAccountBond
		err = json.Unmarshal(data, &dst.FinancialAccountBond);
		if err == nil {
			jsonFinancialAccountBond, _ := json.Marshal(dst.FinancialAccountBond)
			if string(jsonFinancialAccountBond) == "{}" { // empty struct
				dst.FinancialAccountBond = nil
			} else {
				return nil // data stored in dst.FinancialAccountBond, return on the first match
			}
		} else {
			dst.FinancialAccountBond = nil
		}
	}

	// check if the discriminator value is 'CIS'
	if jsonDict["type"] == "CIS" {
		// try to unmarshal JSON data into FinancialAccountCIS
		err = json.Unmarshal(data, &dst.FinancialAccountCIS);
		if err == nil {
			jsonFinancialAccountCIS, _ := json.Marshal(dst.FinancialAccountCIS)
			if string(jsonFinancialAccountCIS) == "{}" { // empty struct
				dst.FinancialAccountCIS = nil
			} else {
				return nil // data stored in dst.FinancialAccountCIS, return on the first match
			}
		} else {
			dst.FinancialAccountCIS = nil
		}
	}

	// check if the discriminator value is 'CertificateOfDeposit'
	if jsonDict["type"] == "CertificateOfDeposit" {
		// try to unmarshal JSON data into FinancialAccountCertificateOfDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountCertificateOfDeposit);
		if err == nil {
			jsonFinancialAccountCertificateOfDeposit, _ := json.Marshal(dst.FinancialAccountCertificateOfDeposit)
			if string(jsonFinancialAccountCertificateOfDeposit) == "{}" { // empty struct
				dst.FinancialAccountCertificateOfDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountCertificateOfDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountCertificateOfDeposit = nil
		}
	}

	// check if the discriminator value is 'CommercialPaper'
	if jsonDict["type"] == "CommercialPaper" {
		// try to unmarshal JSON data into FinancialAccountCommercialPaper
		err = json.Unmarshal(data, &dst.FinancialAccountCommercialPaper);
		if err == nil {
			jsonFinancialAccountCommercialPaper, _ := json.Marshal(dst.FinancialAccountCommercialPaper)
			if string(jsonFinancialAccountCommercialPaper) == "{}" { // empty struct
				dst.FinancialAccountCommercialPaper = nil
			} else {
				return nil // data stored in dst.FinancialAccountCommercialPaper, return on the first match
			}
		} else {
			dst.FinancialAccountCommercialPaper = nil
		}
	}

	// check if the discriminator value is 'CreditCard'
	if jsonDict["type"] == "CreditCard" {
		// try to unmarshal JSON data into FinancialAccountCreditCard
		err = json.Unmarshal(data, &dst.FinancialAccountCreditCard);
		if err == nil {
			jsonFinancialAccountCreditCard, _ := json.Marshal(dst.FinancialAccountCreditCard)
			if string(jsonFinancialAccountCreditCard) == "{}" { // empty struct
				dst.FinancialAccountCreditCard = nil
			} else {
				return nil // data stored in dst.FinancialAccountCreditCard, return on the first match
			}
		} else {
			dst.FinancialAccountCreditCard = nil
		}
	}

	// check if the discriminator value is 'Debenture'
	if jsonDict["type"] == "Debenture" {
		// try to unmarshal JSON data into FinancialAccountDebenture
		err = json.Unmarshal(data, &dst.FinancialAccountDebenture);
		if err == nil {
			jsonFinancialAccountDebenture, _ := json.Marshal(dst.FinancialAccountDebenture)
			if string(jsonFinancialAccountDebenture) == "{}" { // empty struct
				dst.FinancialAccountDebenture = nil
			} else {
				return nil // data stored in dst.FinancialAccountDebenture, return on the first match
			}
		} else {
			dst.FinancialAccountDebenture = nil
		}
	}

	// check if the discriminator value is 'Deposit'
	if jsonDict["type"] == "Deposit" {
		// try to unmarshal JSON data into FinancialAccountDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountDeposit);
		if err == nil {
			jsonFinancialAccountDeposit, _ := json.Marshal(dst.FinancialAccountDeposit)
			if string(jsonFinancialAccountDeposit) == "{}" { // empty struct
				dst.FinancialAccountDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountDeposit = nil
		}
	}

	// check if the discriminator value is 'Epf'
	if jsonDict["type"] == "Epf" {
		// try to unmarshal JSON data into FinancialAccountEpf
		err = json.Unmarshal(data, &dst.FinancialAccountEpf);
		if err == nil {
			jsonFinancialAccountEpf, _ := json.Marshal(dst.FinancialAccountEpf)
			if string(jsonFinancialAccountEpf) == "{}" { // empty struct
				dst.FinancialAccountEpf = nil
			} else {
				return nil // data stored in dst.FinancialAccountEpf, return on the first match
			}
		} else {
			dst.FinancialAccountEpf = nil
		}
	}

	// check if the discriminator value is 'Equity'
	if jsonDict["type"] == "Equity" {
		// try to unmarshal JSON data into FinancialAccountEquity
		err = json.Unmarshal(data, &dst.FinancialAccountEquity);
		if err == nil {
			jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
			if string(jsonFinancialAccountEquity) == "{}" { // empty struct
				dst.FinancialAccountEquity = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquity, return on the first match
			}
		} else {
			dst.FinancialAccountEquity = nil
		}
	}

	// check if the discriminator value is 'Etf'
	if jsonDict["type"] == "Etf" {
		// try to unmarshal JSON data into FinancialAccountEtf
		err = json.Unmarshal(data, &dst.FinancialAccountEtf);
		if err == nil {
			jsonFinancialAccountEtf, _ := json.Marshal(dst.FinancialAccountEtf)
			if string(jsonFinancialAccountEtf) == "{}" { // empty struct
				dst.FinancialAccountEtf = nil
			} else {
				return nil // data stored in dst.FinancialAccountEtf, return on the first match
			}
		} else {
			dst.FinancialAccountEtf = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountAif'
	if jsonDict["type"] == "FinancialAccountAif" {
		// try to unmarshal JSON data into FinancialAccountAif
		err = json.Unmarshal(data, &dst.FinancialAccountAif);
		if err == nil {
			jsonFinancialAccountAif, _ := json.Marshal(dst.FinancialAccountAif)
			if string(jsonFinancialAccountAif) == "{}" { // empty struct
				dst.FinancialAccountAif = nil
			} else {
				return nil // data stored in dst.FinancialAccountAif, return on the first match
			}
		} else {
			dst.FinancialAccountAif = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountBillPayment'
	if jsonDict["type"] == "FinancialAccountBillPayment" {
		// try to unmarshal JSON data into FinancialAccountBillPayment
		err = json.Unmarshal(data, &dst.FinancialAccountBillPayment);
		if err == nil {
			jsonFinancialAccountBillPayment, _ := json.Marshal(dst.FinancialAccountBillPayment)
			if string(jsonFinancialAccountBillPayment) == "{}" { // empty struct
				dst.FinancialAccountBillPayment = nil
			} else {
				return nil // data stored in dst.FinancialAccountBillPayment, return on the first match
			}
		} else {
			dst.FinancialAccountBillPayment = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountBond'
	if jsonDict["type"] == "FinancialAccountBond" {
		// try to unmarshal JSON data into FinancialAccountBond
		err = json.Unmarshal(data, &dst.FinancialAccountBond);
		if err == nil {
			jsonFinancialAccountBond, _ := json.Marshal(dst.FinancialAccountBond)
			if string(jsonFinancialAccountBond) == "{}" { // empty struct
				dst.FinancialAccountBond = nil
			} else {
				return nil // data stored in dst.FinancialAccountBond, return on the first match
			}
		} else {
			dst.FinancialAccountBond = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountCIS'
	if jsonDict["type"] == "FinancialAccountCIS" {
		// try to unmarshal JSON data into FinancialAccountCIS
		err = json.Unmarshal(data, &dst.FinancialAccountCIS);
		if err == nil {
			jsonFinancialAccountCIS, _ := json.Marshal(dst.FinancialAccountCIS)
			if string(jsonFinancialAccountCIS) == "{}" { // empty struct
				dst.FinancialAccountCIS = nil
			} else {
				return nil // data stored in dst.FinancialAccountCIS, return on the first match
			}
		} else {
			dst.FinancialAccountCIS = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountCertificateOfDeposit'
	if jsonDict["type"] == "FinancialAccountCertificateOfDeposit" {
		// try to unmarshal JSON data into FinancialAccountCertificateOfDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountCertificateOfDeposit);
		if err == nil {
			jsonFinancialAccountCertificateOfDeposit, _ := json.Marshal(dst.FinancialAccountCertificateOfDeposit)
			if string(jsonFinancialAccountCertificateOfDeposit) == "{}" { // empty struct
				dst.FinancialAccountCertificateOfDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountCertificateOfDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountCertificateOfDeposit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountCommercialPaper'
	if jsonDict["type"] == "FinancialAccountCommercialPaper" {
		// try to unmarshal JSON data into FinancialAccountCommercialPaper
		err = json.Unmarshal(data, &dst.FinancialAccountCommercialPaper);
		if err == nil {
			jsonFinancialAccountCommercialPaper, _ := json.Marshal(dst.FinancialAccountCommercialPaper)
			if string(jsonFinancialAccountCommercialPaper) == "{}" { // empty struct
				dst.FinancialAccountCommercialPaper = nil
			} else {
				return nil // data stored in dst.FinancialAccountCommercialPaper, return on the first match
			}
		} else {
			dst.FinancialAccountCommercialPaper = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountCreditCard'
	if jsonDict["type"] == "FinancialAccountCreditCard" {
		// try to unmarshal JSON data into FinancialAccountCreditCard
		err = json.Unmarshal(data, &dst.FinancialAccountCreditCard);
		if err == nil {
			jsonFinancialAccountCreditCard, _ := json.Marshal(dst.FinancialAccountCreditCard)
			if string(jsonFinancialAccountCreditCard) == "{}" { // empty struct
				dst.FinancialAccountCreditCard = nil
			} else {
				return nil // data stored in dst.FinancialAccountCreditCard, return on the first match
			}
		} else {
			dst.FinancialAccountCreditCard = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountDebenture'
	if jsonDict["type"] == "FinancialAccountDebenture" {
		// try to unmarshal JSON data into FinancialAccountDebenture
		err = json.Unmarshal(data, &dst.FinancialAccountDebenture);
		if err == nil {
			jsonFinancialAccountDebenture, _ := json.Marshal(dst.FinancialAccountDebenture)
			if string(jsonFinancialAccountDebenture) == "{}" { // empty struct
				dst.FinancialAccountDebenture = nil
			} else {
				return nil // data stored in dst.FinancialAccountDebenture, return on the first match
			}
		} else {
			dst.FinancialAccountDebenture = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountDeposit'
	if jsonDict["type"] == "FinancialAccountDeposit" {
		// try to unmarshal JSON data into FinancialAccountDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountDeposit);
		if err == nil {
			jsonFinancialAccountDeposit, _ := json.Marshal(dst.FinancialAccountDeposit)
			if string(jsonFinancialAccountDeposit) == "{}" { // empty struct
				dst.FinancialAccountDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountDeposit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountEpf'
	if jsonDict["type"] == "FinancialAccountEpf" {
		// try to unmarshal JSON data into FinancialAccountEpf
		err = json.Unmarshal(data, &dst.FinancialAccountEpf);
		if err == nil {
			jsonFinancialAccountEpf, _ := json.Marshal(dst.FinancialAccountEpf)
			if string(jsonFinancialAccountEpf) == "{}" { // empty struct
				dst.FinancialAccountEpf = nil
			} else {
				return nil // data stored in dst.FinancialAccountEpf, return on the first match
			}
		} else {
			dst.FinancialAccountEpf = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountEquity'
	if jsonDict["type"] == "FinancialAccountEquity" {
		// try to unmarshal JSON data into FinancialAccountEquity
		err = json.Unmarshal(data, &dst.FinancialAccountEquity);
		if err == nil {
			jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
			if string(jsonFinancialAccountEquity) == "{}" { // empty struct
				dst.FinancialAccountEquity = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquity, return on the first match
			}
		} else {
			dst.FinancialAccountEquity = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountEtf'
	if jsonDict["type"] == "FinancialAccountEtf" {
		// try to unmarshal JSON data into FinancialAccountEtf
		err = json.Unmarshal(data, &dst.FinancialAccountEtf);
		if err == nil {
			jsonFinancialAccountEtf, _ := json.Marshal(dst.FinancialAccountEtf)
			if string(jsonFinancialAccountEtf) == "{}" { // empty struct
				dst.FinancialAccountEtf = nil
			} else {
				return nil // data stored in dst.FinancialAccountEtf, return on the first match
			}
		} else {
			dst.FinancialAccountEtf = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountGovtSecurity'
	if jsonDict["type"] == "FinancialAccountGovtSecurity" {
		// try to unmarshal JSON data into FinancialAccountGovtSecurity
		err = json.Unmarshal(data, &dst.FinancialAccountGovtSecurity);
		if err == nil {
			jsonFinancialAccountGovtSecurity, _ := json.Marshal(dst.FinancialAccountGovtSecurity)
			if string(jsonFinancialAccountGovtSecurity) == "{}" { // empty struct
				dst.FinancialAccountGovtSecurity = nil
			} else {
				return nil // data stored in dst.FinancialAccountGovtSecurity, return on the first match
			}
		} else {
			dst.FinancialAccountGovtSecurity = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountIdr'
	if jsonDict["type"] == "FinancialAccountIdr" {
		// try to unmarshal JSON data into FinancialAccountIdr
		err = json.Unmarshal(data, &dst.FinancialAccountIdr);
		if err == nil {
			jsonFinancialAccountIdr, _ := json.Marshal(dst.FinancialAccountIdr)
			if string(jsonFinancialAccountIdr) == "{}" { // empty struct
				dst.FinancialAccountIdr = nil
			} else {
				return nil // data stored in dst.FinancialAccountIdr, return on the first match
			}
		} else {
			dst.FinancialAccountIdr = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountInsurancePolicy'
	if jsonDict["type"] == "FinancialAccountInsurancePolicy" {
		// try to unmarshal JSON data into FinancialAccountInsurancePolicy
		err = json.Unmarshal(data, &dst.FinancialAccountInsurancePolicy);
		if err == nil {
			jsonFinancialAccountInsurancePolicy, _ := json.Marshal(dst.FinancialAccountInsurancePolicy)
			if string(jsonFinancialAccountInsurancePolicy) == "{}" { // empty struct
				dst.FinancialAccountInsurancePolicy = nil
			} else {
				return nil // data stored in dst.FinancialAccountInsurancePolicy, return on the first match
			}
		} else {
			dst.FinancialAccountInsurancePolicy = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountInvit'
	if jsonDict["type"] == "FinancialAccountInvit" {
		// try to unmarshal JSON data into FinancialAccountInvit
		err = json.Unmarshal(data, &dst.FinancialAccountInvit);
		if err == nil {
			jsonFinancialAccountInvit, _ := json.Marshal(dst.FinancialAccountInvit)
			if string(jsonFinancialAccountInvit) == "{}" { // empty struct
				dst.FinancialAccountInvit = nil
			} else {
				return nil // data stored in dst.FinancialAccountInvit, return on the first match
			}
		} else {
			dst.FinancialAccountInvit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountLoan'
	if jsonDict["type"] == "FinancialAccountLoan" {
		// try to unmarshal JSON data into FinancialAccountLoan
		err = json.Unmarshal(data, &dst.FinancialAccountLoan);
		if err == nil {
			jsonFinancialAccountLoan, _ := json.Marshal(dst.FinancialAccountLoan)
			if string(jsonFinancialAccountLoan) == "{}" { // empty struct
				dst.FinancialAccountLoan = nil
			} else {
				return nil // data stored in dst.FinancialAccountLoan, return on the first match
			}
		} else {
			dst.FinancialAccountLoan = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountMutualFund'
	if jsonDict["type"] == "FinancialAccountMutualFund" {
		// try to unmarshal JSON data into FinancialAccountMutualFund
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
		if err == nil {
			jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
			if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
				dst.FinancialAccountMutualFund = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFund = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountNps'
	if jsonDict["type"] == "FinancialAccountNps" {
		// try to unmarshal JSON data into FinancialAccountNps
		err = json.Unmarshal(data, &dst.FinancialAccountNps);
		if err == nil {
			jsonFinancialAccountNps, _ := json.Marshal(dst.FinancialAccountNps)
			if string(jsonFinancialAccountNps) == "{}" { // empty struct
				dst.FinancialAccountNps = nil
			} else {
				return nil // data stored in dst.FinancialAccountNps, return on the first match
			}
		} else {
			dst.FinancialAccountNps = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountPpf'
	if jsonDict["type"] == "FinancialAccountPpf" {
		// try to unmarshal JSON data into FinancialAccountPpf
		err = json.Unmarshal(data, &dst.FinancialAccountPpf);
		if err == nil {
			jsonFinancialAccountPpf, _ := json.Marshal(dst.FinancialAccountPpf)
			if string(jsonFinancialAccountPpf) == "{}" { // empty struct
				dst.FinancialAccountPpf = nil
			} else {
				return nil // data stored in dst.FinancialAccountPpf, return on the first match
			}
		} else {
			dst.FinancialAccountPpf = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountRecurringDeposit'
	if jsonDict["type"] == "FinancialAccountRecurringDeposit" {
		// try to unmarshal JSON data into FinancialAccountRecurringDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountRecurringDeposit);
		if err == nil {
			jsonFinancialAccountRecurringDeposit, _ := json.Marshal(dst.FinancialAccountRecurringDeposit)
			if string(jsonFinancialAccountRecurringDeposit) == "{}" { // empty struct
				dst.FinancialAccountRecurringDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountRecurringDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountRecurringDeposit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountReit'
	if jsonDict["type"] == "FinancialAccountReit" {
		// try to unmarshal JSON data into FinancialAccountReit
		err = json.Unmarshal(data, &dst.FinancialAccountReit);
		if err == nil {
			jsonFinancialAccountReit, _ := json.Marshal(dst.FinancialAccountReit)
			if string(jsonFinancialAccountReit) == "{}" { // empty struct
				dst.FinancialAccountReit = nil
			} else {
				return nil // data stored in dst.FinancialAccountReit, return on the first match
			}
		} else {
			dst.FinancialAccountReit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountSip'
	if jsonDict["type"] == "FinancialAccountSip" {
		// try to unmarshal JSON data into FinancialAccountSip
		err = json.Unmarshal(data, &dst.FinancialAccountSip);
		if err == nil {
			jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
			if string(jsonFinancialAccountSip) == "{}" { // empty struct
				dst.FinancialAccountSip = nil
			} else {
				return nil // data stored in dst.FinancialAccountSip, return on the first match
			}
		} else {
			dst.FinancialAccountSip = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountTermDeposit'
	if jsonDict["type"] == "FinancialAccountTermDeposit" {
		// try to unmarshal JSON data into FinancialAccountTermDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountTermDeposit);
		if err == nil {
			jsonFinancialAccountTermDeposit, _ := json.Marshal(dst.FinancialAccountTermDeposit)
			if string(jsonFinancialAccountTermDeposit) == "{}" { // empty struct
				dst.FinancialAccountTermDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountTermDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountTermDeposit = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountUlip'
	if jsonDict["type"] == "FinancialAccountUlip" {
		// try to unmarshal JSON data into FinancialAccountUlip
		err = json.Unmarshal(data, &dst.FinancialAccountUlip);
		if err == nil {
			jsonFinancialAccountUlip, _ := json.Marshal(dst.FinancialAccountUlip)
			if string(jsonFinancialAccountUlip) == "{}" { // empty struct
				dst.FinancialAccountUlip = nil
			} else {
				return nil // data stored in dst.FinancialAccountUlip, return on the first match
			}
		} else {
			dst.FinancialAccountUlip = nil
		}
	}

	// check if the discriminator value is 'GovtSecurity'
	if jsonDict["type"] == "GovtSecurity" {
		// try to unmarshal JSON data into FinancialAccountGovtSecurity
		err = json.Unmarshal(data, &dst.FinancialAccountGovtSecurity);
		if err == nil {
			jsonFinancialAccountGovtSecurity, _ := json.Marshal(dst.FinancialAccountGovtSecurity)
			if string(jsonFinancialAccountGovtSecurity) == "{}" { // empty struct
				dst.FinancialAccountGovtSecurity = nil
			} else {
				return nil // data stored in dst.FinancialAccountGovtSecurity, return on the first match
			}
		} else {
			dst.FinancialAccountGovtSecurity = nil
		}
	}

	// check if the discriminator value is 'Idr'
	if jsonDict["type"] == "Idr" {
		// try to unmarshal JSON data into FinancialAccountIdr
		err = json.Unmarshal(data, &dst.FinancialAccountIdr);
		if err == nil {
			jsonFinancialAccountIdr, _ := json.Marshal(dst.FinancialAccountIdr)
			if string(jsonFinancialAccountIdr) == "{}" { // empty struct
				dst.FinancialAccountIdr = nil
			} else {
				return nil // data stored in dst.FinancialAccountIdr, return on the first match
			}
		} else {
			dst.FinancialAccountIdr = nil
		}
	}

	// check if the discriminator value is 'InsurancePolicy'
	if jsonDict["type"] == "InsurancePolicy" {
		// try to unmarshal JSON data into FinancialAccountInsurancePolicy
		err = json.Unmarshal(data, &dst.FinancialAccountInsurancePolicy);
		if err == nil {
			jsonFinancialAccountInsurancePolicy, _ := json.Marshal(dst.FinancialAccountInsurancePolicy)
			if string(jsonFinancialAccountInsurancePolicy) == "{}" { // empty struct
				dst.FinancialAccountInsurancePolicy = nil
			} else {
				return nil // data stored in dst.FinancialAccountInsurancePolicy, return on the first match
			}
		} else {
			dst.FinancialAccountInsurancePolicy = nil
		}
	}

	// check if the discriminator value is 'Invit'
	if jsonDict["type"] == "Invit" {
		// try to unmarshal JSON data into FinancialAccountInvit
		err = json.Unmarshal(data, &dst.FinancialAccountInvit);
		if err == nil {
			jsonFinancialAccountInvit, _ := json.Marshal(dst.FinancialAccountInvit)
			if string(jsonFinancialAccountInvit) == "{}" { // empty struct
				dst.FinancialAccountInvit = nil
			} else {
				return nil // data stored in dst.FinancialAccountInvit, return on the first match
			}
		} else {
			dst.FinancialAccountInvit = nil
		}
	}

	// check if the discriminator value is 'Loan'
	if jsonDict["type"] == "Loan" {
		// try to unmarshal JSON data into FinancialAccountLoan
		err = json.Unmarshal(data, &dst.FinancialAccountLoan);
		if err == nil {
			jsonFinancialAccountLoan, _ := json.Marshal(dst.FinancialAccountLoan)
			if string(jsonFinancialAccountLoan) == "{}" { // empty struct
				dst.FinancialAccountLoan = nil
			} else {
				return nil // data stored in dst.FinancialAccountLoan, return on the first match
			}
		} else {
			dst.FinancialAccountLoan = nil
		}
	}

	// check if the discriminator value is 'MutualFund'
	if jsonDict["type"] == "MutualFund" {
		// try to unmarshal JSON data into FinancialAccountMutualFund
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
		if err == nil {
			jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
			if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
				dst.FinancialAccountMutualFund = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFund = nil
		}
	}

	// check if the discriminator value is 'Nps'
	if jsonDict["type"] == "Nps" {
		// try to unmarshal JSON data into FinancialAccountNps
		err = json.Unmarshal(data, &dst.FinancialAccountNps);
		if err == nil {
			jsonFinancialAccountNps, _ := json.Marshal(dst.FinancialAccountNps)
			if string(jsonFinancialAccountNps) == "{}" { // empty struct
				dst.FinancialAccountNps = nil
			} else {
				return nil // data stored in dst.FinancialAccountNps, return on the first match
			}
		} else {
			dst.FinancialAccountNps = nil
		}
	}

	// check if the discriminator value is 'Ppf'
	if jsonDict["type"] == "Ppf" {
		// try to unmarshal JSON data into FinancialAccountPpf
		err = json.Unmarshal(data, &dst.FinancialAccountPpf);
		if err == nil {
			jsonFinancialAccountPpf, _ := json.Marshal(dst.FinancialAccountPpf)
			if string(jsonFinancialAccountPpf) == "{}" { // empty struct
				dst.FinancialAccountPpf = nil
			} else {
				return nil // data stored in dst.FinancialAccountPpf, return on the first match
			}
		} else {
			dst.FinancialAccountPpf = nil
		}
	}

	// check if the discriminator value is 'RecurringDeposit'
	if jsonDict["type"] == "RecurringDeposit" {
		// try to unmarshal JSON data into FinancialAccountRecurringDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountRecurringDeposit);
		if err == nil {
			jsonFinancialAccountRecurringDeposit, _ := json.Marshal(dst.FinancialAccountRecurringDeposit)
			if string(jsonFinancialAccountRecurringDeposit) == "{}" { // empty struct
				dst.FinancialAccountRecurringDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountRecurringDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountRecurringDeposit = nil
		}
	}

	// check if the discriminator value is 'Reit'
	if jsonDict["type"] == "Reit" {
		// try to unmarshal JSON data into FinancialAccountReit
		err = json.Unmarshal(data, &dst.FinancialAccountReit);
		if err == nil {
			jsonFinancialAccountReit, _ := json.Marshal(dst.FinancialAccountReit)
			if string(jsonFinancialAccountReit) == "{}" { // empty struct
				dst.FinancialAccountReit = nil
			} else {
				return nil // data stored in dst.FinancialAccountReit, return on the first match
			}
		} else {
			dst.FinancialAccountReit = nil
		}
	}

	// check if the discriminator value is 'Sip'
	if jsonDict["type"] == "Sip" {
		// try to unmarshal JSON data into FinancialAccountSip
		err = json.Unmarshal(data, &dst.FinancialAccountSip);
		if err == nil {
			jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
			if string(jsonFinancialAccountSip) == "{}" { // empty struct
				dst.FinancialAccountSip = nil
			} else {
				return nil // data stored in dst.FinancialAccountSip, return on the first match
			}
		} else {
			dst.FinancialAccountSip = nil
		}
	}

	// check if the discriminator value is 'TermDeposit'
	if jsonDict["type"] == "TermDeposit" {
		// try to unmarshal JSON data into FinancialAccountTermDeposit
		err = json.Unmarshal(data, &dst.FinancialAccountTermDeposit);
		if err == nil {
			jsonFinancialAccountTermDeposit, _ := json.Marshal(dst.FinancialAccountTermDeposit)
			if string(jsonFinancialAccountTermDeposit) == "{}" { // empty struct
				dst.FinancialAccountTermDeposit = nil
			} else {
				return nil // data stored in dst.FinancialAccountTermDeposit, return on the first match
			}
		} else {
			dst.FinancialAccountTermDeposit = nil
		}
	}

	// check if the discriminator value is 'Ulip'
	if jsonDict["type"] == "Ulip" {
		// try to unmarshal JSON data into FinancialAccountUlip
		err = json.Unmarshal(data, &dst.FinancialAccountUlip);
		if err == nil {
			jsonFinancialAccountUlip, _ := json.Marshal(dst.FinancialAccountUlip)
			if string(jsonFinancialAccountUlip) == "{}" { // empty struct
				dst.FinancialAccountUlip = nil
			} else {
				return nil // data stored in dst.FinancialAccountUlip, return on the first match
			}
		} else {
			dst.FinancialAccountUlip = nil
		}
	}

	// try to unmarshal JSON data into FinancialAccountAif
	err = json.Unmarshal(data, &dst.FinancialAccountAif);
	if err == nil {
		jsonFinancialAccountAif, _ := json.Marshal(dst.FinancialAccountAif)
		if string(jsonFinancialAccountAif) == "{}" { // empty struct
			dst.FinancialAccountAif = nil
		} else {
			return nil // data stored in dst.FinancialAccountAif, return on the first match
		}
	} else {
		dst.FinancialAccountAif = nil
	}

	// try to unmarshal JSON data into FinancialAccountBillPayment
	err = json.Unmarshal(data, &dst.FinancialAccountBillPayment);
	if err == nil {
		jsonFinancialAccountBillPayment, _ := json.Marshal(dst.FinancialAccountBillPayment)
		if string(jsonFinancialAccountBillPayment) == "{}" { // empty struct
			dst.FinancialAccountBillPayment = nil
		} else {
			return nil // data stored in dst.FinancialAccountBillPayment, return on the first match
		}
	} else {
		dst.FinancialAccountBillPayment = nil
	}

	// try to unmarshal JSON data into FinancialAccountBond
	err = json.Unmarshal(data, &dst.FinancialAccountBond);
	if err == nil {
		jsonFinancialAccountBond, _ := json.Marshal(dst.FinancialAccountBond)
		if string(jsonFinancialAccountBond) == "{}" { // empty struct
			dst.FinancialAccountBond = nil
		} else {
			return nil // data stored in dst.FinancialAccountBond, return on the first match
		}
	} else {
		dst.FinancialAccountBond = nil
	}

	// try to unmarshal JSON data into FinancialAccountCIS
	err = json.Unmarshal(data, &dst.FinancialAccountCIS);
	if err == nil {
		jsonFinancialAccountCIS, _ := json.Marshal(dst.FinancialAccountCIS)
		if string(jsonFinancialAccountCIS) == "{}" { // empty struct
			dst.FinancialAccountCIS = nil
		} else {
			return nil // data stored in dst.FinancialAccountCIS, return on the first match
		}
	} else {
		dst.FinancialAccountCIS = nil
	}

	// try to unmarshal JSON data into FinancialAccountCertificateOfDeposit
	err = json.Unmarshal(data, &dst.FinancialAccountCertificateOfDeposit);
	if err == nil {
		jsonFinancialAccountCertificateOfDeposit, _ := json.Marshal(dst.FinancialAccountCertificateOfDeposit)
		if string(jsonFinancialAccountCertificateOfDeposit) == "{}" { // empty struct
			dst.FinancialAccountCertificateOfDeposit = nil
		} else {
			return nil // data stored in dst.FinancialAccountCertificateOfDeposit, return on the first match
		}
	} else {
		dst.FinancialAccountCertificateOfDeposit = nil
	}

	// try to unmarshal JSON data into FinancialAccountCommercialPaper
	err = json.Unmarshal(data, &dst.FinancialAccountCommercialPaper);
	if err == nil {
		jsonFinancialAccountCommercialPaper, _ := json.Marshal(dst.FinancialAccountCommercialPaper)
		if string(jsonFinancialAccountCommercialPaper) == "{}" { // empty struct
			dst.FinancialAccountCommercialPaper = nil
		} else {
			return nil // data stored in dst.FinancialAccountCommercialPaper, return on the first match
		}
	} else {
		dst.FinancialAccountCommercialPaper = nil
	}

	// try to unmarshal JSON data into FinancialAccountCreditCard
	err = json.Unmarshal(data, &dst.FinancialAccountCreditCard);
	if err == nil {
		jsonFinancialAccountCreditCard, _ := json.Marshal(dst.FinancialAccountCreditCard)
		if string(jsonFinancialAccountCreditCard) == "{}" { // empty struct
			dst.FinancialAccountCreditCard = nil
		} else {
			return nil // data stored in dst.FinancialAccountCreditCard, return on the first match
		}
	} else {
		dst.FinancialAccountCreditCard = nil
	}

	// try to unmarshal JSON data into FinancialAccountDebenture
	err = json.Unmarshal(data, &dst.FinancialAccountDebenture);
	if err == nil {
		jsonFinancialAccountDebenture, _ := json.Marshal(dst.FinancialAccountDebenture)
		if string(jsonFinancialAccountDebenture) == "{}" { // empty struct
			dst.FinancialAccountDebenture = nil
		} else {
			return nil // data stored in dst.FinancialAccountDebenture, return on the first match
		}
	} else {
		dst.FinancialAccountDebenture = nil
	}

	// try to unmarshal JSON data into FinancialAccountDeposit
	err = json.Unmarshal(data, &dst.FinancialAccountDeposit);
	if err == nil {
		jsonFinancialAccountDeposit, _ := json.Marshal(dst.FinancialAccountDeposit)
		if string(jsonFinancialAccountDeposit) == "{}" { // empty struct
			dst.FinancialAccountDeposit = nil
		} else {
			return nil // data stored in dst.FinancialAccountDeposit, return on the first match
		}
	} else {
		dst.FinancialAccountDeposit = nil
	}

	// try to unmarshal JSON data into FinancialAccountEpf
	err = json.Unmarshal(data, &dst.FinancialAccountEpf);
	if err == nil {
		jsonFinancialAccountEpf, _ := json.Marshal(dst.FinancialAccountEpf)
		if string(jsonFinancialAccountEpf) == "{}" { // empty struct
			dst.FinancialAccountEpf = nil
		} else {
			return nil // data stored in dst.FinancialAccountEpf, return on the first match
		}
	} else {
		dst.FinancialAccountEpf = nil
	}

	// try to unmarshal JSON data into FinancialAccountEquity
	err = json.Unmarshal(data, &dst.FinancialAccountEquity);
	if err == nil {
		jsonFinancialAccountEquity, _ := json.Marshal(dst.FinancialAccountEquity)
		if string(jsonFinancialAccountEquity) == "{}" { // empty struct
			dst.FinancialAccountEquity = nil
		} else {
			return nil // data stored in dst.FinancialAccountEquity, return on the first match
		}
	} else {
		dst.FinancialAccountEquity = nil
	}

	// try to unmarshal JSON data into FinancialAccountEtf
	err = json.Unmarshal(data, &dst.FinancialAccountEtf);
	if err == nil {
		jsonFinancialAccountEtf, _ := json.Marshal(dst.FinancialAccountEtf)
		if string(jsonFinancialAccountEtf) == "{}" { // empty struct
			dst.FinancialAccountEtf = nil
		} else {
			return nil // data stored in dst.FinancialAccountEtf, return on the first match
		}
	} else {
		dst.FinancialAccountEtf = nil
	}

	// try to unmarshal JSON data into FinancialAccountGovtSecurity
	err = json.Unmarshal(data, &dst.FinancialAccountGovtSecurity);
	if err == nil {
		jsonFinancialAccountGovtSecurity, _ := json.Marshal(dst.FinancialAccountGovtSecurity)
		if string(jsonFinancialAccountGovtSecurity) == "{}" { // empty struct
			dst.FinancialAccountGovtSecurity = nil
		} else {
			return nil // data stored in dst.FinancialAccountGovtSecurity, return on the first match
		}
	} else {
		dst.FinancialAccountGovtSecurity = nil
	}

	// try to unmarshal JSON data into FinancialAccountIdr
	err = json.Unmarshal(data, &dst.FinancialAccountIdr);
	if err == nil {
		jsonFinancialAccountIdr, _ := json.Marshal(dst.FinancialAccountIdr)
		if string(jsonFinancialAccountIdr) == "{}" { // empty struct
			dst.FinancialAccountIdr = nil
		} else {
			return nil // data stored in dst.FinancialAccountIdr, return on the first match
		}
	} else {
		dst.FinancialAccountIdr = nil
	}

	// try to unmarshal JSON data into FinancialAccountInsurancePolicy
	err = json.Unmarshal(data, &dst.FinancialAccountInsurancePolicy);
	if err == nil {
		jsonFinancialAccountInsurancePolicy, _ := json.Marshal(dst.FinancialAccountInsurancePolicy)
		if string(jsonFinancialAccountInsurancePolicy) == "{}" { // empty struct
			dst.FinancialAccountInsurancePolicy = nil
		} else {
			return nil // data stored in dst.FinancialAccountInsurancePolicy, return on the first match
		}
	} else {
		dst.FinancialAccountInsurancePolicy = nil
	}

	// try to unmarshal JSON data into FinancialAccountInvit
	err = json.Unmarshal(data, &dst.FinancialAccountInvit);
	if err == nil {
		jsonFinancialAccountInvit, _ := json.Marshal(dst.FinancialAccountInvit)
		if string(jsonFinancialAccountInvit) == "{}" { // empty struct
			dst.FinancialAccountInvit = nil
		} else {
			return nil // data stored in dst.FinancialAccountInvit, return on the first match
		}
	} else {
		dst.FinancialAccountInvit = nil
	}

	// try to unmarshal JSON data into FinancialAccountLoan
	err = json.Unmarshal(data, &dst.FinancialAccountLoan);
	if err == nil {
		jsonFinancialAccountLoan, _ := json.Marshal(dst.FinancialAccountLoan)
		if string(jsonFinancialAccountLoan) == "{}" { // empty struct
			dst.FinancialAccountLoan = nil
		} else {
			return nil // data stored in dst.FinancialAccountLoan, return on the first match
		}
	} else {
		dst.FinancialAccountLoan = nil
	}

	// try to unmarshal JSON data into FinancialAccountMutualFund
	err = json.Unmarshal(data, &dst.FinancialAccountMutualFund);
	if err == nil {
		jsonFinancialAccountMutualFund, _ := json.Marshal(dst.FinancialAccountMutualFund)
		if string(jsonFinancialAccountMutualFund) == "{}" { // empty struct
			dst.FinancialAccountMutualFund = nil
		} else {
			return nil // data stored in dst.FinancialAccountMutualFund, return on the first match
		}
	} else {
		dst.FinancialAccountMutualFund = nil
	}

	// try to unmarshal JSON data into FinancialAccountNps
	err = json.Unmarshal(data, &dst.FinancialAccountNps);
	if err == nil {
		jsonFinancialAccountNps, _ := json.Marshal(dst.FinancialAccountNps)
		if string(jsonFinancialAccountNps) == "{}" { // empty struct
			dst.FinancialAccountNps = nil
		} else {
			return nil // data stored in dst.FinancialAccountNps, return on the first match
		}
	} else {
		dst.FinancialAccountNps = nil
	}

	// try to unmarshal JSON data into FinancialAccountPpf
	err = json.Unmarshal(data, &dst.FinancialAccountPpf);
	if err == nil {
		jsonFinancialAccountPpf, _ := json.Marshal(dst.FinancialAccountPpf)
		if string(jsonFinancialAccountPpf) == "{}" { // empty struct
			dst.FinancialAccountPpf = nil
		} else {
			return nil // data stored in dst.FinancialAccountPpf, return on the first match
		}
	} else {
		dst.FinancialAccountPpf = nil
	}

	// try to unmarshal JSON data into FinancialAccountRecurringDeposit
	err = json.Unmarshal(data, &dst.FinancialAccountRecurringDeposit);
	if err == nil {
		jsonFinancialAccountRecurringDeposit, _ := json.Marshal(dst.FinancialAccountRecurringDeposit)
		if string(jsonFinancialAccountRecurringDeposit) == "{}" { // empty struct
			dst.FinancialAccountRecurringDeposit = nil
		} else {
			return nil // data stored in dst.FinancialAccountRecurringDeposit, return on the first match
		}
	} else {
		dst.FinancialAccountRecurringDeposit = nil
	}

	// try to unmarshal JSON data into FinancialAccountReit
	err = json.Unmarshal(data, &dst.FinancialAccountReit);
	if err == nil {
		jsonFinancialAccountReit, _ := json.Marshal(dst.FinancialAccountReit)
		if string(jsonFinancialAccountReit) == "{}" { // empty struct
			dst.FinancialAccountReit = nil
		} else {
			return nil // data stored in dst.FinancialAccountReit, return on the first match
		}
	} else {
		dst.FinancialAccountReit = nil
	}

	// try to unmarshal JSON data into FinancialAccountSip
	err = json.Unmarshal(data, &dst.FinancialAccountSip);
	if err == nil {
		jsonFinancialAccountSip, _ := json.Marshal(dst.FinancialAccountSip)
		if string(jsonFinancialAccountSip) == "{}" { // empty struct
			dst.FinancialAccountSip = nil
		} else {
			return nil // data stored in dst.FinancialAccountSip, return on the first match
		}
	} else {
		dst.FinancialAccountSip = nil
	}

	// try to unmarshal JSON data into FinancialAccountTermDeposit
	err = json.Unmarshal(data, &dst.FinancialAccountTermDeposit);
	if err == nil {
		jsonFinancialAccountTermDeposit, _ := json.Marshal(dst.FinancialAccountTermDeposit)
		if string(jsonFinancialAccountTermDeposit) == "{}" { // empty struct
			dst.FinancialAccountTermDeposit = nil
		} else {
			return nil // data stored in dst.FinancialAccountTermDeposit, return on the first match
		}
	} else {
		dst.FinancialAccountTermDeposit = nil
	}

	// try to unmarshal JSON data into FinancialAccountUlip
	err = json.Unmarshal(data, &dst.FinancialAccountUlip);
	if err == nil {
		jsonFinancialAccountUlip, _ := json.Marshal(dst.FinancialAccountUlip)
		if string(jsonFinancialAccountUlip) == "{}" { // empty struct
			dst.FinancialAccountUlip = nil
		} else {
			return nil // data stored in dst.FinancialAccountUlip, return on the first match
		}
	} else {
		dst.FinancialAccountUlip = nil
	}

	return fmt.Errorf("Data failed to match schemas in anyOf(FinancialAccount)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *FinancialAccount) MarshalJSON() ([]byte, error) {
	if src.FinancialAccountAif != nil {
		return json.Marshal(&src.FinancialAccountAif)
	}

	if src.FinancialAccountBillPayment != nil {
		return json.Marshal(&src.FinancialAccountBillPayment)
	}

	if src.FinancialAccountBond != nil {
		return json.Marshal(&src.FinancialAccountBond)
	}

	if src.FinancialAccountCIS != nil {
		return json.Marshal(&src.FinancialAccountCIS)
	}

	if src.FinancialAccountCertificateOfDeposit != nil {
		return json.Marshal(&src.FinancialAccountCertificateOfDeposit)
	}

	if src.FinancialAccountCommercialPaper != nil {
		return json.Marshal(&src.FinancialAccountCommercialPaper)
	}

	if src.FinancialAccountCreditCard != nil {
		return json.Marshal(&src.FinancialAccountCreditCard)
	}

	if src.FinancialAccountDebenture != nil {
		return json.Marshal(&src.FinancialAccountDebenture)
	}

	if src.FinancialAccountDeposit != nil {
		return json.Marshal(&src.FinancialAccountDeposit)
	}

	if src.FinancialAccountEpf != nil {
		return json.Marshal(&src.FinancialAccountEpf)
	}

	if src.FinancialAccountEquity != nil {
		return json.Marshal(&src.FinancialAccountEquity)
	}

	if src.FinancialAccountEtf != nil {
		return json.Marshal(&src.FinancialAccountEtf)
	}

	if src.FinancialAccountGovtSecurity != nil {
		return json.Marshal(&src.FinancialAccountGovtSecurity)
	}

	if src.FinancialAccountIdr != nil {
		return json.Marshal(&src.FinancialAccountIdr)
	}

	if src.FinancialAccountInsurancePolicy != nil {
		return json.Marshal(&src.FinancialAccountInsurancePolicy)
	}

	if src.FinancialAccountInvit != nil {
		return json.Marshal(&src.FinancialAccountInvit)
	}

	if src.FinancialAccountLoan != nil {
		return json.Marshal(&src.FinancialAccountLoan)
	}

	if src.FinancialAccountMutualFund != nil {
		return json.Marshal(&src.FinancialAccountMutualFund)
	}

	if src.FinancialAccountNps != nil {
		return json.Marshal(&src.FinancialAccountNps)
	}

	if src.FinancialAccountPpf != nil {
		return json.Marshal(&src.FinancialAccountPpf)
	}

	if src.FinancialAccountRecurringDeposit != nil {
		return json.Marshal(&src.FinancialAccountRecurringDeposit)
	}

	if src.FinancialAccountReit != nil {
		return json.Marshal(&src.FinancialAccountReit)
	}

	if src.FinancialAccountSip != nil {
		return json.Marshal(&src.FinancialAccountSip)
	}

	if src.FinancialAccountTermDeposit != nil {
		return json.Marshal(&src.FinancialAccountTermDeposit)
	}

	if src.FinancialAccountUlip != nil {
		return json.Marshal(&src.FinancialAccountUlip)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableFinancialAccount struct {
	value *FinancialAccount
	isSet bool
}

func (v NullableFinancialAccount) Get() *FinancialAccount {
	return v.value
}

func (v *NullableFinancialAccount) Set(val *FinancialAccount) {
	v.value = val
	v.isSet = true
}

func (v NullableFinancialAccount) IsSet() bool {
	return v.isSet
}

func (v *NullableFinancialAccount) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFinancialAccount(val *FinancialAccount) *NullableFinancialAccount {
	return &NullableFinancialAccount{value: val, isSet: true}
}

func (v NullableFinancialAccount) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFinancialAccount) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


