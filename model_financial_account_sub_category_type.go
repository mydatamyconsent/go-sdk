/*
My Data My Consent - Developer API

Unleashing the power of consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: 1.0
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/sdk

import (
	"encoding/json"
	"fmt"
)

// FinancialAccountSubCategoryType the model 'FinancialAccountSubCategoryType'
type FinancialAccountSubCategoryType string

// List of FinancialAccountSubCategoryType
const (
	EPF FinancialAccountSubCategoryType = "Epf"
	PPF FinancialAccountSubCategoryType = "Ppf"
	DEPOSIT FinancialAccountSubCategoryType = "Deposit"
	RECURRING_DEPOSIT FinancialAccountSubCategoryType = "RecurringDeposit"
	TERM_DEPOSIT FinancialAccountSubCategoryType = "TermDeposit"
	SAVINGS_ACCOUNT FinancialAccountSubCategoryType = "SavingsAccount"
	ULIP FinancialAccountSubCategoryType = "Ulip"
	LIFE_INSURANCE FinancialAccountSubCategoryType = "LifeInsurance"
	TERM_INSURANCE FinancialAccountSubCategoryType = "TermInsurance"
	GENERAL_INSURANCE FinancialAccountSubCategoryType = "GeneralInsurance"
	HOME_LOAN FinancialAccountSubCategoryType = "HomeLoan"
	STUDENT_LOAN FinancialAccountSubCategoryType = "StudentLoan"
	SECURED_CREDIT_CARD FinancialAccountSubCategoryType = "SecuredCreditCard"
	UNSECURED_CREDIT_CARD FinancialAccountSubCategoryType = "UnsecuredCreditCard"
	AIF FinancialAccountSubCategoryType = "Aif"
	BOND FinancialAccountSubCategoryType = "Bond"
	CD FinancialAccountSubCategoryType = "Cd"
	CIS FinancialAccountSubCategoryType = "Cis"
	CP FinancialAccountSubCategoryType = "Cp"
	DEBENTURE FinancialAccountSubCategoryType = "Debenture"
	EQUITY FinancialAccountSubCategoryType = "Equity"
	ETF FinancialAccountSubCategoryType = "Etf"
	GOVT_SECURITY FinancialAccountSubCategoryType = "GovtSecurity"
	IDR FinancialAccountSubCategoryType = "Idr"
	INVIT FinancialAccountSubCategoryType = "Invit"
	MUTUAL_FUND FinancialAccountSubCategoryType = "MutualFund"
	NPS FinancialAccountSubCategoryType = "Nps"
	REIT FinancialAccountSubCategoryType = "Reit"
	SIP FinancialAccountSubCategoryType = "Sip"
	BILL FinancialAccountSubCategoryType = "Bill"
	REWARD FinancialAccountSubCategoryType = "Reward"
)

// All allowed values of FinancialAccountSubCategoryType enum
var AllowedFinancialAccountSubCategoryTypeEnumValues = []FinancialAccountSubCategoryType{
	"Epf",
	"Ppf",
	"Deposit",
	"RecurringDeposit",
	"TermDeposit",
	"SavingsAccount",
	"Ulip",
	"LifeInsurance",
	"TermInsurance",
	"GeneralInsurance",
	"HomeLoan",
	"StudentLoan",
	"SecuredCreditCard",
	"UnsecuredCreditCard",
	"Aif",
	"Bond",
	"Cd",
	"Cis",
	"Cp",
	"Debenture",
	"Equity",
	"Etf",
	"GovtSecurity",
	"Idr",
	"Invit",
	"MutualFund",
	"Nps",
	"Reit",
	"Sip",
	"Bill",
	"Reward",
}

func (v *FinancialAccountSubCategoryType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := FinancialAccountSubCategoryType(value)
	for _, existing := range AllowedFinancialAccountSubCategoryTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid FinancialAccountSubCategoryType", value)
}

// NewFinancialAccountSubCategoryTypeFromValue returns a pointer to a valid FinancialAccountSubCategoryType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewFinancialAccountSubCategoryTypeFromValue(v string) (*FinancialAccountSubCategoryType, error) {
	ev := FinancialAccountSubCategoryType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for FinancialAccountSubCategoryType: valid values are %v", v, AllowedFinancialAccountSubCategoryTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v FinancialAccountSubCategoryType) IsValid() bool {
	for _, existing := range AllowedFinancialAccountSubCategoryTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to FinancialAccountSubCategoryType value
func (v FinancialAccountSubCategoryType) Ptr() *FinancialAccountSubCategoryType {
	return &v
}

type NullableFinancialAccountSubCategoryType struct {
	value *FinancialAccountSubCategoryType
	isSet bool
}

func (v NullableFinancialAccountSubCategoryType) Get() *FinancialAccountSubCategoryType {
	return v.value
}

func (v *NullableFinancialAccountSubCategoryType) Set(val *FinancialAccountSubCategoryType) {
	v.value = val
	v.isSet = true
}

func (v NullableFinancialAccountSubCategoryType) IsSet() bool {
	return v.isSet
}

func (v *NullableFinancialAccountSubCategoryType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFinancialAccountSubCategoryType(val *FinancialAccountSubCategoryType) *NullableFinancialAccountSubCategoryType {
	return &NullableFinancialAccountSubCategoryType{value: val, isSet: true}
}

func (v NullableFinancialAccountSubCategoryType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFinancialAccountSubCategoryType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

