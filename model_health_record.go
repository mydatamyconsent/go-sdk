/*
My Data My Consent - Developer API

Unleashing the power of consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: 1.0
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/sdk

import (
	"encoding/json"
	"time"
	"fmt"
)

// HealthRecord struct for HealthRecord
type HealthRecord struct {
	HealthRecordAllergyDetails *HealthRecordAllergyDetails
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *HealthRecord) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	// check if the discriminator value is 'Allergy'
	if jsonDict["type"] == "Allergy" {
		// try to unmarshal JSON data into HealthRecordAllergyDetails
		err = json.Unmarshal(data, &dst.HealthRecordAllergyDetails);
		if err == nil {
			jsonHealthRecordAllergyDetails, _ := json.Marshal(dst.HealthRecordAllergyDetails)
			if string(jsonHealthRecordAllergyDetails) == "{}" { // empty struct
				dst.HealthRecordAllergyDetails = nil
			} else {
				return nil // data stored in dst.HealthRecordAllergyDetails, return on the first match
			}
		} else {
			dst.HealthRecordAllergyDetails = nil
		}
	}

	// check if the discriminator value is 'HealthRecord_AllergyDetails'
	if jsonDict["type"] == "HealthRecord_AllergyDetails" {
		// try to unmarshal JSON data into HealthRecordAllergyDetails
		err = json.Unmarshal(data, &dst.HealthRecordAllergyDetails);
		if err == nil {
			jsonHealthRecordAllergyDetails, _ := json.Marshal(dst.HealthRecordAllergyDetails)
			if string(jsonHealthRecordAllergyDetails) == "{}" { // empty struct
				dst.HealthRecordAllergyDetails = nil
			} else {
				return nil // data stored in dst.HealthRecordAllergyDetails, return on the first match
			}
		} else {
			dst.HealthRecordAllergyDetails = nil
		}
	}

	// try to unmarshal JSON data into HealthRecordAllergyDetails
	err = json.Unmarshal(data, &dst.HealthRecordAllergyDetails);
	if err == nil {
		jsonHealthRecordAllergyDetails, _ := json.Marshal(dst.HealthRecordAllergyDetails)
		if string(jsonHealthRecordAllergyDetails) == "{}" { // empty struct
			dst.HealthRecordAllergyDetails = nil
		} else {
			return nil // data stored in dst.HealthRecordAllergyDetails, return on the first match
		}
	} else {
		dst.HealthRecordAllergyDetails = nil
	}

	return fmt.Errorf("Data failed to match schemas in anyOf(HealthRecord)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *HealthRecord) MarshalJSON() ([]byte, error) {
	if src.HealthRecordAllergyDetails != nil {
		return json.Marshal(&src.HealthRecordAllergyDetails)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableHealthRecord struct {
	value *HealthRecord
	isSet bool
}

func (v NullableHealthRecord) Get() *HealthRecord {
	return v.value
}

func (v *NullableHealthRecord) Set(val *HealthRecord) {
	v.value = val
	v.isSet = true
}

func (v NullableHealthRecord) IsSet() bool {
	return v.isSet
}

func (v *NullableHealthRecord) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableHealthRecord(val *HealthRecord) *NullableHealthRecord {
	return &NullableHealthRecord{value: val, isSet: true}
}

func (v NullableHealthRecord) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableHealthRecord) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


