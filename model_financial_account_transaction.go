/*
My Data My Consent - Developer API

Unleashing the power of consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: 1.0
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/sdk

import (
	"encoding/json"
	"time"
	"fmt"
)

// FinancialAccountTransaction struct for FinancialAccountTransaction
type FinancialAccountTransaction struct {
	FinancialAccountEquityTransaction *FinancialAccountEquityTransaction
	FinancialAccountMutualFundTransaction *FinancialAccountMutualFundTransaction
	FinancialAccountSipTransaction *FinancialAccountSipTransaction
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *FinancialAccountTransaction) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	// check if the discriminator value is 'EquityTransaction'
	if jsonDict["type"] == "EquityTransaction" {
		// try to unmarshal JSON data into FinancialAccountEquityTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountEquityTransaction);
		if err == nil {
			jsonFinancialAccountEquityTransaction, _ := json.Marshal(dst.FinancialAccountEquityTransaction)
			if string(jsonFinancialAccountEquityTransaction) == "{}" { // empty struct
				dst.FinancialAccountEquityTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquityTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountEquityTransaction = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountEquityTransaction'
	if jsonDict["type"] == "FinancialAccountEquityTransaction" {
		// try to unmarshal JSON data into FinancialAccountEquityTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountEquityTransaction);
		if err == nil {
			jsonFinancialAccountEquityTransaction, _ := json.Marshal(dst.FinancialAccountEquityTransaction)
			if string(jsonFinancialAccountEquityTransaction) == "{}" { // empty struct
				dst.FinancialAccountEquityTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountEquityTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountEquityTransaction = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountMutualFundTransaction'
	if jsonDict["type"] == "FinancialAccountMutualFundTransaction" {
		// try to unmarshal JSON data into FinancialAccountMutualFundTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFundTransaction);
		if err == nil {
			jsonFinancialAccountMutualFundTransaction, _ := json.Marshal(dst.FinancialAccountMutualFundTransaction)
			if string(jsonFinancialAccountMutualFundTransaction) == "{}" { // empty struct
				dst.FinancialAccountMutualFundTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFundTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFundTransaction = nil
		}
	}

	// check if the discriminator value is 'FinancialAccountSipTransaction'
	if jsonDict["type"] == "FinancialAccountSipTransaction" {
		// try to unmarshal JSON data into FinancialAccountSipTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountSipTransaction);
		if err == nil {
			jsonFinancialAccountSipTransaction, _ := json.Marshal(dst.FinancialAccountSipTransaction)
			if string(jsonFinancialAccountSipTransaction) == "{}" { // empty struct
				dst.FinancialAccountSipTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountSipTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountSipTransaction = nil
		}
	}

	// check if the discriminator value is 'MutualFundTransaction'
	if jsonDict["type"] == "MutualFundTransaction" {
		// try to unmarshal JSON data into FinancialAccountMutualFundTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountMutualFundTransaction);
		if err == nil {
			jsonFinancialAccountMutualFundTransaction, _ := json.Marshal(dst.FinancialAccountMutualFundTransaction)
			if string(jsonFinancialAccountMutualFundTransaction) == "{}" { // empty struct
				dst.FinancialAccountMutualFundTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountMutualFundTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountMutualFundTransaction = nil
		}
	}

	// check if the discriminator value is 'SipTransaction'
	if jsonDict["type"] == "SipTransaction" {
		// try to unmarshal JSON data into FinancialAccountSipTransaction
		err = json.Unmarshal(data, &dst.FinancialAccountSipTransaction);
		if err == nil {
			jsonFinancialAccountSipTransaction, _ := json.Marshal(dst.FinancialAccountSipTransaction)
			if string(jsonFinancialAccountSipTransaction) == "{}" { // empty struct
				dst.FinancialAccountSipTransaction = nil
			} else {
				return nil // data stored in dst.FinancialAccountSipTransaction, return on the first match
			}
		} else {
			dst.FinancialAccountSipTransaction = nil
		}
	}

	// try to unmarshal JSON data into FinancialAccountEquityTransaction
	err = json.Unmarshal(data, &dst.FinancialAccountEquityTransaction);
	if err == nil {
		jsonFinancialAccountEquityTransaction, _ := json.Marshal(dst.FinancialAccountEquityTransaction)
		if string(jsonFinancialAccountEquityTransaction) == "{}" { // empty struct
			dst.FinancialAccountEquityTransaction = nil
		} else {
			return nil // data stored in dst.FinancialAccountEquityTransaction, return on the first match
		}
	} else {
		dst.FinancialAccountEquityTransaction = nil
	}

	// try to unmarshal JSON data into FinancialAccountMutualFundTransaction
	err = json.Unmarshal(data, &dst.FinancialAccountMutualFundTransaction);
	if err == nil {
		jsonFinancialAccountMutualFundTransaction, _ := json.Marshal(dst.FinancialAccountMutualFundTransaction)
		if string(jsonFinancialAccountMutualFundTransaction) == "{}" { // empty struct
			dst.FinancialAccountMutualFundTransaction = nil
		} else {
			return nil // data stored in dst.FinancialAccountMutualFundTransaction, return on the first match
		}
	} else {
		dst.FinancialAccountMutualFundTransaction = nil
	}

	// try to unmarshal JSON data into FinancialAccountSipTransaction
	err = json.Unmarshal(data, &dst.FinancialAccountSipTransaction);
	if err == nil {
		jsonFinancialAccountSipTransaction, _ := json.Marshal(dst.FinancialAccountSipTransaction)
		if string(jsonFinancialAccountSipTransaction) == "{}" { // empty struct
			dst.FinancialAccountSipTransaction = nil
		} else {
			return nil // data stored in dst.FinancialAccountSipTransaction, return on the first match
		}
	} else {
		dst.FinancialAccountSipTransaction = nil
	}

	return fmt.Errorf("Data failed to match schemas in anyOf(FinancialAccountTransaction)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src *FinancialAccountTransaction) MarshalJSON() ([]byte, error) {
	if src.FinancialAccountEquityTransaction != nil {
		return json.Marshal(&src.FinancialAccountEquityTransaction)
	}

	if src.FinancialAccountMutualFundTransaction != nil {
		return json.Marshal(&src.FinancialAccountMutualFundTransaction)
	}

	if src.FinancialAccountSipTransaction != nil {
		return json.Marshal(&src.FinancialAccountSipTransaction)
	}

	return nil, nil // no data in anyOf schemas
}

type NullableFinancialAccountTransaction struct {
	value *FinancialAccountTransaction
	isSet bool
}

func (v NullableFinancialAccountTransaction) Get() *FinancialAccountTransaction {
	return v.value
}

func (v *NullableFinancialAccountTransaction) Set(val *FinancialAccountTransaction) {
	v.value = val
	v.isSet = true
}

func (v NullableFinancialAccountTransaction) IsSet() bool {
	return v.isSet
}

func (v *NullableFinancialAccountTransaction) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableFinancialAccountTransaction(val *FinancialAccountTransaction) *NullableFinancialAccountTransaction {
	return &NullableFinancialAccountTransaction{value: val, isSet: true}
}

func (v NullableFinancialAccountTransaction) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableFinancialAccountTransaction) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


