/*
My Data My Consent - Developer API

Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.

API version: v1
Contact: support@mydatamyconsent.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package github.com/mydatamyconsent/go-sdk

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// Linger please
var (
	_ context.Context
)

// DataConsentsApiService DataConsentsApi service
type DataConsentsApiService service

type ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	accountId string
}


func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest) Execute() (*FinancialAccount, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdAccountsAccountIdGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdAccountsAccountIdGet Get individual consented financial account details based on account id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param accountId
 @return ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsAccountIdGet(ctx context.Context, consentId string, accountId string) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest {
	return ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return FinancialAccount
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsAccountIdGetExecute(r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdGetRequest) (*FinancialAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FinancialAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdAccountsAccountIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	accountId string
	filters *string
	pageNo *int32
	pageSize *int32
	fromDate *time.Time
	toDate *time.Time
}

func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) Filters(filters string) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.filters = &filters
	return r
}
func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) PageNo(pageNo int32) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.pageNo = &pageNo
	return r
}
func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) PageSize(pageSize int32) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) FromDate(fromDate time.Time) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) ToDate(toDate time.Time) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.toDate = &toDate
	return r
}

func (r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) Execute() (*UserAccountFinancialTransactionsDtoPaginatedList, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGet Get consented financial account transactions of an individual based on accountId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param accountId
 @return ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGet(ctx context.Context, consentId string, accountId string) ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest {
	return ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return UserAccountFinancialTransactionsDtoPaginatedList
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetExecute(r ApiV1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGetRequest) (*UserAccountFinancialTransactionsDtoPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAccountFinancialTransactionsDtoPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdAccountsAccountIdTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/accounts/{accountId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		localVarQueryParams.Add("filters", parameterToString(*r.filters, ""))
	}
	if r.pageNo != nil {
		localVarQueryParams.Add("pageNo", parameterToString(*r.pageNo, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdAccountsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsIndividualsConsentIdAccountsGetRequest) Execute() (*DataConsentFinancialsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdAccountsGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdAccountsGet Get all individual financial accounts in a consent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsIndividualsConsentIdAccountsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsGet(ctx context.Context, consentId string) ApiV1ConsentsIndividualsConsentIdAccountsGetRequest {
	return ApiV1ConsentsIndividualsConsentIdAccountsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentFinancialsDto
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdAccountsGetExecute(r ApiV1ConsentsIndividualsConsentIdAccountsGetRequest) (*DataConsentFinancialsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentFinancialsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdAccountsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	documentId string
}


func (r ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest) Execute() (*UserDocumentDownloadDto, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGet Download a individuals consented document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId consentId.
 @param documentId documentId.
 @return ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGet(ctx context.Context, consentId string, documentId string) ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest {
	return ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return UserDocumentDownloadDto
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetExecute(r ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGetRequest) (*UserDocumentDownloadDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDocumentDownloadDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdDocumentsDocumentIdDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/documents/{documentId}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	documentId string
}


func (r ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest) Execute() (*UserDocumentDetailsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdDocumentsDocumentIdGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdDocumentsDocumentIdGet Get individuals consent document based on document id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param documentId Document Id.
 @return ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsDocumentIdGet(ctx context.Context, consentId string, documentId string) ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest {
	return ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return UserDocumentDetailsDto
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsDocumentIdGetExecute(r ApiV1ConsentsIndividualsConsentIdDocumentsDocumentIdGetRequest) (*UserDocumentDetailsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDocumentDetailsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdDocumentsDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest) Execute() (*DataConsentDocumentsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdDocumentsGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdDocumentsGet Get the individual documents based on ConsentId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsGet(ctx context.Context, consentId string) ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest {
	return ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentDocumentsDto
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdDocumentsGetExecute(r ApiV1ConsentsIndividualsConsentIdDocumentsGetRequest) (*DataConsentDocumentsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentDocumentsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdDocumentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsConsentIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsIndividualsConsentIdGetRequest) Execute() (*DataConsentDetailsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsConsentIdGetExecute(r)
}

/*
V1ConsentsIndividualsConsentIdGet Get individuals consent details by consent id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsIndividualsConsentIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdGet(ctx context.Context, consentId string) ApiV1ConsentsIndividualsConsentIdGetRequest {
	return ApiV1ConsentsIndividualsConsentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentDetailsDto
func (a *DataConsentsApiService) V1ConsentsIndividualsConsentIdGetExecute(r ApiV1ConsentsIndividualsConsentIdGetRequest) (*DataConsentDetailsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentDetailsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsConsentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals/{consentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsIndividualsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	pageNo *int32
	pageSize *int32
	status *DataConsentStatus
	startDate *time.Time
	endDate *time.Time
}

func (r ApiV1ConsentsIndividualsGetRequest) PageNo(pageNo int32) ApiV1ConsentsIndividualsGetRequest {
	r.pageNo = &pageNo
	return r
}
func (r ApiV1ConsentsIndividualsGetRequest) PageSize(pageSize int32) ApiV1ConsentsIndividualsGetRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiV1ConsentsIndividualsGetRequest) Status(status DataConsentStatus) ApiV1ConsentsIndividualsGetRequest {
	r.status = &status
	return r
}
func (r ApiV1ConsentsIndividualsGetRequest) StartDate(startDate time.Time) ApiV1ConsentsIndividualsGetRequest {
	r.startDate = &startDate
	return r
}
func (r ApiV1ConsentsIndividualsGetRequest) EndDate(endDate time.Time) ApiV1ConsentsIndividualsGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiV1ConsentsIndividualsGetRequest) Execute() (*UserDataConsentInfoDtoPaginatedList, *http.Response, error) {
	return r.ApiService.V1ConsentsIndividualsGetExecute(r)
}

/*
V1ConsentsIndividualsGet Get the list of Consents Sent to Individuals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ConsentsIndividualsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsIndividualsGet(ctx context.Context) ApiV1ConsentsIndividualsGetRequest {
	return ApiV1ConsentsIndividualsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserDataConsentInfoDtoPaginatedList
func (a *DataConsentsApiService) V1ConsentsIndividualsGetExecute(r ApiV1ConsentsIndividualsGetRequest) (*UserDataConsentInfoDtoPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserDataConsentInfoDtoPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsIndividualsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/individuals"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNo != nil {
		localVarQueryParams.Add("pageNo", parameterToString(*r.pageNo, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	accountId string
}


func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest) Execute() (*OrganizationFinancialAccountDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdAccountsAccountIdGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdAccountsAccountIdGet Get orgnization consented financial account details based on account id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param accountId
 @return ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsAccountIdGet(ctx context.Context, consentId string, accountId string) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return OrganizationFinancialAccountDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsAccountIdGetExecute(r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdGetRequest) (*OrganizationFinancialAccountDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationFinancialAccountDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdAccountsAccountIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/accounts/{accountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	accountId string
	filters *string
	pageNo *int32
	pageSize *int32
	fromDate *time.Time
	toDate *time.Time
}

func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) Filters(filters string) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.filters = &filters
	return r
}
func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) PageNo(pageNo int32) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.pageNo = &pageNo
	return r
}
func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) PageSize(pageSize int32) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) FromDate(fromDate time.Time) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.fromDate = &fromDate
	return r
}
func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) ToDate(toDate time.Time) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	r.toDate = &toDate
	return r
}

func (r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) Execute() (*OrganizationFinancialTransactionsDtoPaginatedList, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGet Get consented financial account transactions of an organization based on accountId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param accountId
 @return ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGet(ctx context.Context, consentId string, accountId string) ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return OrganizationFinancialTransactionsDtoPaginatedList
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetExecute(r ApiV1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGetRequest) (*OrganizationFinancialTransactionsDtoPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationFinancialTransactionsDtoPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdAccountsAccountIdTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/accounts/{accountId}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", url.PathEscape(parameterToString(r.accountId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filters != nil {
		localVarQueryParams.Add("filters", parameterToString(*r.filters, ""))
	}
	if r.pageNo != nil {
		localVarQueryParams.Add("pageNo", parameterToString(*r.pageNo, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.fromDate != nil {
		localVarQueryParams.Add("fromDate", parameterToString(*r.fromDate, ""))
	}
	if r.toDate != nil {
		localVarQueryParams.Add("toDate", parameterToString(*r.toDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest) Execute() (*DataConsentFinancialsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdAccountsGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdAccountsGet Get all organizational financial accounts in a consent.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsGet(ctx context.Context, consentId string) ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentFinancialsDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdAccountsGetExecute(r ApiV1ConsentsOrganizationsConsentIdAccountsGetRequest) (*DataConsentFinancialsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentFinancialsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdAccountsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	documentId string
}


func (r ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest) Execute() (*OrganizationDocumentDownloadDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGet Download organizations consented document.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param documentId
 @return ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGet(ctx context.Context, consentId string, documentId string) ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return OrganizationDocumentDownloadDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetExecute(r ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGetRequest) (*OrganizationDocumentDownloadDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationDocumentDownloadDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdDocumentsDocumentIdDownloadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/documents/{documentId}/download"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
	documentId string
}


func (r ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest) Execute() (*OrganizationDocumentDetailsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdDocumentsDocumentIdGet Get organizations consent document based on document id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @param documentId
 @return ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsDocumentIdGet(ctx context.Context, consentId string, documentId string) ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
		documentId: documentId,
	}
}

// Execute executes the request
//  @return OrganizationDocumentDetailsDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetExecute(r ApiV1ConsentsOrganizationsConsentIdDocumentsDocumentIdGetRequest) (*OrganizationDocumentDetailsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationDocumentDetailsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdDocumentsDocumentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/documents/{documentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"documentId"+"}", url.PathEscape(parameterToString(r.documentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest) Execute() (*DataConsentDocumentsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdDocumentsGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdDocumentsGet Get the organizations documents based on ConsentId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsGet(ctx context.Context, consentId string) ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentDocumentsDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdDocumentsGetExecute(r ApiV1ConsentsOrganizationsConsentIdDocumentsGetRequest) (*DataConsentDocumentsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentDocumentsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdDocumentsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}/documents"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsConsentIdGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	consentId string
}


func (r ApiV1ConsentsOrganizationsConsentIdGetRequest) Execute() (*DataConsentDetailsDto, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsConsentIdGetExecute(r)
}

/*
V1ConsentsOrganizationsConsentIdGet Get organizations consent details by consent id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param consentId
 @return ApiV1ConsentsOrganizationsConsentIdGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdGet(ctx context.Context, consentId string) ApiV1ConsentsOrganizationsConsentIdGetRequest {
	return ApiV1ConsentsOrganizationsConsentIdGetRequest{
		ApiService: a,
		ctx: ctx,
		consentId: consentId,
	}
}

// Execute executes the request
//  @return DataConsentDetailsDto
func (a *DataConsentsApiService) V1ConsentsOrganizationsConsentIdGetExecute(r ApiV1ConsentsOrganizationsConsentIdGetRequest) (*DataConsentDetailsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataConsentDetailsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsConsentIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations/{consentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"consentId"+"}", url.PathEscape(parameterToString(r.consentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1ConsentsOrganizationsGetRequest struct {
	ctx context.Context
	ApiService *DataConsentsApiService
	pageNo *int32
	pageSize *int32
	status *DataConsentStatus
	startDate *time.Time
	endDate *time.Time
}

func (r ApiV1ConsentsOrganizationsGetRequest) PageNo(pageNo int32) ApiV1ConsentsOrganizationsGetRequest {
	r.pageNo = &pageNo
	return r
}
func (r ApiV1ConsentsOrganizationsGetRequest) PageSize(pageSize int32) ApiV1ConsentsOrganizationsGetRequest {
	r.pageSize = &pageSize
	return r
}
func (r ApiV1ConsentsOrganizationsGetRequest) Status(status DataConsentStatus) ApiV1ConsentsOrganizationsGetRequest {
	r.status = &status
	return r
}
func (r ApiV1ConsentsOrganizationsGetRequest) StartDate(startDate time.Time) ApiV1ConsentsOrganizationsGetRequest {
	r.startDate = &startDate
	return r
}
func (r ApiV1ConsentsOrganizationsGetRequest) EndDate(endDate time.Time) ApiV1ConsentsOrganizationsGetRequest {
	r.endDate = &endDate
	return r
}

func (r ApiV1ConsentsOrganizationsGetRequest) Execute() (*OrganizationDataConsentInfoDtoPaginatedList, *http.Response, error) {
	return r.ApiService.V1ConsentsOrganizationsGetExecute(r)
}

/*
V1ConsentsOrganizationsGet Get the list of data consents sent for organizations.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1ConsentsOrganizationsGetRequest
*/
func (a *DataConsentsApiService) V1ConsentsOrganizationsGet(ctx context.Context) ApiV1ConsentsOrganizationsGetRequest {
	return ApiV1ConsentsOrganizationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrganizationDataConsentInfoDtoPaginatedList
func (a *DataConsentsApiService) V1ConsentsOrganizationsGetExecute(r ApiV1ConsentsOrganizationsGetRequest) (*OrganizationDataConsentInfoDtoPaginatedList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrganizationDataConsentInfoDtoPaginatedList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataConsentsApiService.V1ConsentsOrganizationsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/consents/organizations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNo != nil {
		localVarQueryParams.Add("pageNo", parameterToString(*r.pageNo, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
